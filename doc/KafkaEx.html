<!DOCTYPE html>
<html>
  <head>
    <title>KafkaEx</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
    <link rel="stylesheet" href="css/elixir.css" type="text/css" media="screen" charset="utf-8" />
    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/highlight.pack.js"></script>
    <script type="text/javascript" charset="utf-8">
      hljs.initHighlightingOnLoad();
      hljs.configure({languages: []}); //disable autodetect
    </script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <section id="content">
      <div class="breadcrumbs">kafka_ex v0.1.0 &rarr; <a href="overview.html">Overview</a> &rarr; <a href="KafkaEx.html">KafkaEx</a></div>
      <h1>
        KafkaEx
        
      </h1>

      <ul class="summary_links">
        
          <li><a href="#summary">Summary</a></li>
        
        
          <li><a href="#types_details">Types</a></li>
        
        
          <li><a href="#functions_details">Functions</a></li>
        
        
        
      </ul>

      

      

      
        <h2 id="summary">Summary<span class="detail_header_links"><a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a></span></h2>
        <table class="summary">
          <tr>
  <td class="summary_signature"><a href="#consumer_group_metadata/2">consumer_group_metadata(worker_name, consumer_group)</a></td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#create_worker/2">create_worker(name, worker_init \\ [])</a></td>
  
    <td class="summary_synopsis"><p>create_worker creates KafkaEx workers</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#earliest_offset/3">earliest_offset(topic, partition, name \\ KafkaEx.Server)</a></td>
  
    <td class="summary_synopsis"><p>Get the offset of the earliest message still persistent in Kafka</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#fetch/3">fetch(topic, partition, opts \\ [])</a></td>
  
    <td class="summary_synopsis"><p>Fetch a set of messages from Kafka from the given topic and partition ID</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#latest_offset/3">latest_offset(topic, partition, name \\ KafkaEx.Server)</a></td>
  
    <td class="summary_synopsis"><p>Get the offset of the latest message written to Kafka</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#metadata/1">metadata(opts \\ [])</a></td>
  
    <td class="summary_synopsis"><p>Return metadata for the given topic; returns for all topics if topic is empty string</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#offset/4">offset(topic, partition, time, name \\ KafkaEx.Server)</a></td>
  
    <td class="summary_synopsis"><p>Get the offset of the message sent at the specified date/time</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#offset_commit/2">offset_commit(worker_name, offset_commit_request)</a></td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#offset_fetch/2">offset_fetch(worker_name, offset_fetch_request)</a></td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#produce/4">produce(topic, partition, value, opts \\ [])</a></td>
  
    <td class="summary_synopsis"><p>Produces messages to kafka logs</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#start/2">start(type, args)</a></td>
  
    <td class="summary_synopsis"><p>Callback implementation of <a href="http://www.erlang.org/doc/man/application.html#start-2"><code class="inline">:application.start/2</code></a></p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#stop_streaming/1">stop_streaming(opts \\ [])</a></td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#stream/3">stream(topic, partition, opts \\ [])</a></td>
  
    <td class="summary_synopsis"><p>Returns a stream that consumes fetched messages.
This puts the specified worker in streaming mode and blocks the worker indefinitely.
The handler is a normal GenEvent handler so you can supply a custom handler, otherwise a default handler is used</p>
</td>
  
</tr>

        </table>
      

      
        <section id="types_details" class="details_list">
          <h2>Types <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a></h2>
          <div class="type_detail">
  <p class="typespec" id="t:uri/0">
    <a href="#t:uri/0">uri</a> :: [{binary | char_list, number}]
  </p>
  
</div>
<div class="type_detail">
  <p class="typespec" id="t:worker_init/0">
    <a href="#t:worker_init/0">worker_init</a> :: [uris: <a href="#t:uri/0">uri</a>, consumer_group: binary]
  </p>
  
</div>

        </section>
      

      
        <section id="functions_details" class="details_list">
          <h2>Functions</h2>
          <section class="detail">
  <div class="detail_header" id="consumer_group_metadata/2">
    <span class="signature"><strong>consumer_group_metadata(worker_name, consumer_group)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#consumer_group_metadata/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>consumer_group_metadata(atom, binary) :: <a href="KafkaEx.Protocol.ConsumerMetadata.Response.html#t:t/0">KafkaEx.Protocol.ConsumerMetadata.Response.t</a></li>
      
    </ul>
  
  <section class="docstring">
    
  </section>
  
</section>
<section class="detail">
  <div class="detail_header" id="create_worker/2">
    <span class="signature"><strong>create_worker(name, worker_init \\ [])</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#create_worker/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>create_worker(atom, <a href="KafkaEx.html#t:worker_init/0">KafkaEx.worker_init</a>) :: <a href="http://elixir-lang.org/docs/stable/elixir/Supervisor.html#t:on_start_child/0">Supervisor.on_start_child</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>create_worker creates KafkaEx workers</p>
<h2>Example</h2>
<pre><code class="elixir">iex&gt; KafkaEx.create_worker(:pr) # where :pr is the name of the worker created
{:ok, #PID&lt;0.171.0&gt;}
iex&gt; KafkaEx.create_worker(:pr, uris: [{&quot;localhost&quot;, 9092}]) #if no consumer_group is specified &quot;kafka_ex&quot; would be used as the default
{:ok, #PID&lt;0.172.0&gt;}
iex&gt; KafkaEx.create_worker(:pr, [uris: [{&quot;localhost&quot;, 9092}], consumer_group: &quot;foo&quot;])
{:ok, #PID&lt;0.173.0&gt;}</code></pre>

  </section>
  
</section>
<section class="detail">
  <div class="detail_header" id="earliest_offset/3">
    <span class="signature"><strong>earliest_offset(topic, partition, name \\ KafkaEx.Server)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#earliest_offset/3" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>earliest_offset(binary, integer, atom | pid) :: {atom, %{}}</li>
      
    </ul>
  
  <section class="docstring">
    <p>Get the offset of the earliest message still persistent in Kafka</p>
<h2>Example</h2>
<pre><code class="elixir">iex&gt; KafkaEx.earliest_offset(&quot;foo&quot;, 0)
[%KafkaEx.Protocol.Offset.Response{partition_offsets: [%{error_code: 0, offset: [0], partition: 0}], topic: &quot;foo&quot;}]</code></pre>

  </section>
  
</section>
<section class="detail">
  <div class="detail_header" id="fetch/3">
    <span class="signature"><strong>fetch(topic, partition, opts \\ [])</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#fetch/3" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>fetch(binary, number, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0">Keyword.t</a>) :: {atom, %{}}</li>
      
    </ul>
  
  <section class="docstring">
    <p>Fetch a set of messages from Kafka from the given topic and partition ID</p>
<p>Optional arguments(KeywordList)</p>
<ul>
<li>offset: When supplied the fetch would start from this offset, otherwise would start from the last committed offset of the consumer_group the worker belongs to.
</li>
<li>worker_name: the worker we want to run this fetch request through. Default is KafkaEx.Server
</li>
<li>wait_time: maximum amount of time in milliseconds to block waiting if insufficient data is available at the time the request is issued. Default is 10
</li>
<li>min_bytes: minimum number of bytes of messages that must be available to give a response. If the client sets this to 0 the server will always respond immediately, however if there is no new data since their last request they will just get back empty message sets. If this is set to 1, the server will respond as soon as at least one partition has at least 1 byte of data or the specified timeout occurs. By setting higher values in combination with the timeout the consumer can tune for throughput and trade a little additional latency for reading only large chunks of data (e.g. setting wait_time to 100 and setting min_bytes 64000 would allow the server to wait up to 100ms to try to accumulate 64k of data before responding). Default is 1
</li>
<li>max_bytes: maximum bytes to include in the message set for this partition. This helps bound the size of the response. Default is 1,000,000
</li>
<li>auto_commit: specifies if the last offset should be commited or not. Default is true
</li>
</ul>
<h2>Example</h2>
<pre><code class="elixir">iex&gt; KafkaEx.fetch(&quot;foo&quot;, 0, offset: 0)
[
  %KafkaEx.Protocol.Fetch.Response{partitions: [
    %{error_code: 0, hw_mark_offset: 1, message_set: [
      %{attributes: 0, crc: 748947812, key: nil, offset: 0, value: &quot;hey foo&quot;}
    ], partition: 0}
  ], topic: &quot;foo&quot;}
]</code></pre>

  </section>
  
</section>
<section class="detail">
  <div class="detail_header" id="latest_offset/3">
    <span class="signature"><strong>latest_offset(topic, partition, name \\ KafkaEx.Server)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#latest_offset/3" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>latest_offset(binary, integer, atom | pid) :: {atom, %{}}</li>
      
    </ul>
  
  <section class="docstring">
    <p>Get the offset of the latest message written to Kafka</p>
<h2>Example</h2>
<pre><code class="elixir">iex&gt; KafkaEx.latest_offset(&quot;foo&quot;, 0)
[%KafkaEx.Protocol.Offset.Response{partition_offsets: [%{error_code: 0, offsets: [16], partition: 0}], topic: &quot;foo&quot;}]</code></pre>

  </section>
  
</section>
<section class="detail">
  <div class="detail_header" id="metadata/1">
    <span class="signature"><strong>metadata(opts \\ [])</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#metadata/1" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>metadata(<a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0">Keyword.t</a>) :: %{}</li>
      
    </ul>
  
  <section class="docstring">
    <p>Return metadata for the given topic; returns for all topics if topic is empty string</p>
<p>Optional arguments(KeywordList)</p>
<ul>
<li>worker_name: the worker we want to run this metadata request through, when none is provided the default worker <a href="KafkaEx.Server.html"><code class="inline">KafkaEx.Server</code></a> is used
</li>
<li>topic: name of the topic for which metadata is requested, when none is provided all metadata is retrieved
</li>
</ul>
<h2>Example</h2>
<pre><code class="elixir">iex&gt; KafkaEx.create_worker(:mt)
iex&gt; KafkaEx.metadata(topic: &quot;foo&quot;, worker_name: :mt)
%KafkaEx.Protocol.Metadata.Response{brokers: [%KafkaEx.Protocol.Metadata.Broker{host: &quot;192.168.59.103&quot;,
   node_id: 49162, port: 49162, socket: nil}],
 topic_metadatas: [%KafkaEx.Protocol.Metadata.TopicMetadata{error_code: 0,
   partition_metadatas: [%KafkaEx.Protocol.Metadata.PartitionMetadata{error_code: 0,
     isrs: [49162], leader: 49162, partition_id: 0, replicas: [49162]}],
   topic: &quot;foo&quot;}]}</code></pre>

  </section>
  
</section>
<section class="detail">
  <div class="detail_header" id="offset/4">
    <span class="signature"><strong>offset(topic, partition, time, name \\ KafkaEx.Server)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#offset/4" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>offset(binary, number, :calendar.datetime | atom, atom | pid) :: {atom, %{}}</li>
      
    </ul>
  
  <section class="docstring">
    <p>Get the offset of the message sent at the specified date/time</p>
<h2>Example</h2>
<pre><code class="elixir">iex&gt; KafkaEx.offset(&quot;foo&quot;, 0, {{2015, 3, 29}, {23, 56, 40}}) # Note that the time specified should match/be ahead of time on the server that kafka runs
[%KafkaEx.Protocol.Offset.Response{partition_offsets: [%{error_code: 0, offset: [256], partition: 0}], topic: &quot;foo&quot;}]</code></pre>

  </section>
  
</section>
<section class="detail">
  <div class="detail_header" id="offset_commit/2">
    <span class="signature"><strong>offset_commit(worker_name, offset_commit_request)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#offset_commit/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>offset_commit(atom, <a href="KafkaEx.Protocol.OffsetCommit.Request.html#t:t/0">KafkaEx.Protocol.OffsetCommit.Request.t</a>) :: <a href="KafkaEx.Protocol.OffsetCommit.Response.html#t:t/0">KafkaEx.Protocol.OffsetCommit.Response.t</a></li>
      
    </ul>
  
  <section class="docstring">
    
  </section>
  
</section>
<section class="detail">
  <div class="detail_header" id="offset_fetch/2">
    <span class="signature"><strong>offset_fetch(worker_name, offset_fetch_request)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#offset_fetch/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>offset_fetch(atom, <a href="KafkaEx.Protocol.OffsetFetch.Request.html#t:t/0">KafkaEx.Protocol.OffsetFetch.Request.t</a>) :: <a href="KafkaEx.Protocol.OffsetFetch.Response.html#t:t/0">KafkaEx.Protocol.OffsetFetch.Response.t</a></li>
      
    </ul>
  
  <section class="docstring">
    
  </section>
  
</section>
<section class="detail">
  <div class="detail_header" id="produce/4">
    <span class="signature"><strong>produce(topic, partition, value, opts \\ [])</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#produce/4" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>produce(binary, number, binary, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0">Keyword.t</a>) :: :ok | {:ok, %{}}</li>
      
    </ul>
  
  <section class="docstring">
    <p>Produces messages to kafka logs</p>
<p>Optional arguments(KeywordList)</p>
<ul>
<li>worker_name: the worker we want to run this metadata request through, when none is provided the default worker <a href="KafkaEx.Server.html"><code class="inline">KafkaEx.Server</code></a> is used
</li>
<li>key: is used for partition assignment, can be nil, when none is provided it is defaulted to nil
</li>
<li>require_acks: indicates how many acknowledgements the servers should receive before responding to the request. If it is 0 the server will not send any response (this is the only case where the server will not reply to a request). If it is 1, the server will wait the data is written to the local log before sending a response. If it is -1 the server will block until the message is committed by all in sync replicas before sending a response. For any number &gt; 1 the server will block waiting for this number of acknowledgements to occur (but the server will never wait for more acknowledgements than there are in-sync replicas), default is 0
</li>
<li>timeout: provides a maximum time in milliseconds the server can await the receipt of the number of acknowledgements in RequiredAcks, default is 100 milliseconds
</li>
</ul>
<h2>Example</h2>
<pre><code class="elixir">iex&gt; KafkaEx.produce(&quot;bar&quot;, 0, &quot;hey&quot;)
:ok
iex&gt; KafkaEx.produce(&quot;foo&quot;, 0, &quot;hey&quot;, [worker_name: :pr, require_acks: 1])
[%KafkaEx.Protocol.Produce.Response{partitions: [%{error_code: 0, offset: 75, partition: 0}], topic: &quot;foo&quot;}]</code></pre>

  </section>
  
</section>
<section class="detail">
  <div class="detail_header" id="start/2">
    <span class="signature"><strong>start(type, args)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#start/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Callback implementation of <a href="http://www.erlang.org/doc/man/application.html#start-2"><code class="inline">:application.start/2</code></a>.</p>

  </section>
  
</section>
<section class="detail">
  <div class="detail_header" id="stop_streaming/1">
    <span class="signature"><strong>stop_streaming(opts \\ [])</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#stop_streaming/1" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>stop_streaming(<a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0">Keyword.t</a>) :: :ok</li>
      
    </ul>
  
  <section class="docstring">
    
  </section>
  
</section>
<section class="detail">
  <div class="detail_header" id="stream/3">
    <span class="signature"><strong>stream(topic, partition, opts \\ [])</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#stream/3" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>stream(binary, number, <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0">Keyword.t</a>) :: <a href="http://elixir-lang.org/docs/stable/elixir/GenEvent.Stream.html#t:t/0">GenEvent.Stream.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Returns a stream that consumes fetched messages.
This puts the specified worker in streaming mode and blocks the worker indefinitely.
The handler is a normal GenEvent handler so you can supply a custom handler, otherwise a default handler is used.</p>
<p>This function should be used with care as the queue is unbounded and can cause OOM.</p>
<p>Optional arguments(KeywordList)</p>
<ul>
<li>worker_name: the worker we want to run this metadata request through, when none is provided the default worker <a href="KafkaEx.Server.html"><code class="inline">KafkaEx.Server</code></a> is used
</li>
<li>offset: offset to begin this fetch from, when none is provided 0 is assumed
</li>
<li>handler: the handler we want to handle the streaming events, when none is provided the default KafkaExHandler is used
</li>
<li>auto_commit: specifies if the last offset should be commited or not. Default is true
</li>
</ul>
<h2>Example</h2>
<pre><code class="elixir">iex&gt; KafkaEx.create_worker(:stream, [{&quot;localhost&quot;, 9092}])
{:ok, #PID&lt;0.196.0&gt;}
iex&gt; KafkaEx.produce(&quot;foo&quot;, 0, &quot;hey&quot;, worker_name: :stream)
:ok
iex&gt; KafkaEx.produce(&quot;foo&quot;, 0, &quot;hi&quot;, worker_name: :stream)
:ok
iex&gt; KafkaEx.stream(&quot;foo&quot;, 0) |&gt; Enum.take(2)
[%{attributes: 0, crc: 4264455069, key: nil, offset: 0, value: &quot;hey&quot;},
 %{attributes: 0, crc: 4251893211, key: nil, offset: 1, value: &quot;hi&quot;}]</code></pre>

  </section>
  
</section>

        </section>
      

      

      
    </section>
  </body>
</html>
